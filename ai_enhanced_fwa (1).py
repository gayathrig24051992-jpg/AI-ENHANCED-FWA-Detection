# -*- coding: utf-8 -*-
"""AI Enhanced FWA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16vviAZey7zW_t3DRFIlDZB3GmjGG0u8M
"""

# app.py

# -*- coding: utf-8 -*-
import os
import uuid
import time
from io import BytesIO

import streamlit as st
import boto3
from PyPDF2 import PdfReader
from pdf2image import convert_from_bytes
from PIL import Image

# --- Configuration & AWS Clients ---

# Load secrets from Streamlit
try:
    aws_conf = st.secrets["aws"]
    AWS_ACCESS_KEY_ID = aws_conf["aws_access_key_id"]
    AWS_SECRET_ACCESS_KEY = aws_conf["aws_secret_access_key"]
    AWS_REGION = aws_conf.get("aws_region", "ap-south-1")

    bedrock_conf = st.secrets["bedrock"]
    AGENT_ID = bedrock_conf["agent_id"]
    AGENT_ALIAS_ID = bedrock_conf["agent_alias_id"]
except KeyError as e:
    st.error(f"Missing Streamlit secret: {e}")
    st.stop()

# Boto3 clients
s3_client = boto3.client(
    "s3",
    region_name=AWS_REGION,
    aws_access_key_id=AWS_ACCESS_KEY_ID,
    aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
)
ddb = boto3.resource(
    "dynamodb",
    region_name=AWS_REGION,
    aws_access_key_id=AWS_ACCESS_KEY_ID,
    aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
).Table("ClaimsAudit")
comprehend_med = boto3.client(
    "comprehendmedical",
    region_name=AWS_REGION,
    aws_access_key_id=AWS_ACCESS_KEY_ID,
    aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
)


# --- Helper Functions ---

def upload_to_s3(bucket: str, key: str, data: bytes):
    s3_client.put_object(Bucket=bucket, Key=key, Body=data)
    return f"s3://{bucket}/{key}"


def log_to_dynamodb(item: dict):
    ddb.put_item(Item=item)


def extract_text_from_pdf(uploaded_bytes: bytes, pages: list[int]) -> str:
    reader = PdfReader(BytesIO(uploaded_bytes))
    text = ""
    for p in pages:
        idx = p - 1
        if 0 <= idx < len(reader.pages):
            page_text = reader.pages[idx].extract_text() or ""
            text += f"--- Page {p} ---\n{page_text}\n\n"
    return text.strip()


def invoke_bedrock_agent(text: str, prompt_prefix: str) -> str:
    client = boto3.client(
        "bedrock-agent-runtime",
        region_name=AWS_REGION,
        aws_access_key_id=AWS_ACCESS_KEY_ID,
        aws_secret_access_key=AWS_SECRET_ACCESS_KEY,
    )
    session_id = str(uuid.uuid4())
    full_prompt = f"{prompt_prefix}\n\nContext:\n{text}"
    resp = client.invoke_agent(
        agentId=AGENT_ID,
        agentAliasId=AGENT_ALIAS_ID,
        sessionId=session_id,
        inputText=full_prompt,
    )
    out = ""
    for evt in resp["completion"]:
        chunk = evt.get("chunk", {})
        if chunk.get("bytes"):
            out += chunk["bytes"].decode("utf-8")
    return out or "I DO NOT HAVE ANSWER AT PRESENT"


def detect_phi_entities(text: str) -> list[dict]:
    resp = comprehend_med.detect_entities_v2(Text=text)
    return resp.get("Entities", [])


def mask_phi(text: str, entities: list[dict]) -> str:
    redacted = text
    for ent in sorted(entities, key=lambda x: x["BeginOffset"], reverse=True):
        start, end = ent["BeginOffset"], ent["EndOffset"]
        redacted = redacted[:start] + "[REDACTED]" + redacted[end:]
    return redacted


def compute_risk_score(text: str) -> int:
    keywords = [
        "fraud", "duplicate", "overcharge", "waste", "abuse", "inflated", "error"
    ]
    count = sum(text.lower().count(k) for k in keywords)
    return min(count * 10, 100)


# --- Streamlit App UI ---

st.set_page_config(
    page_title="Medisight AI Enhanced",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Sidebar: User Login & Role
st.sidebar.header("üë§ User Login")
username = st.sidebar.text_input("Username", value="", help="Enter your username")
role = st.sidebar.selectbox(
    "Role", options=["processor", "auditor"], help="Select your role"
)

if not username:
    st.sidebar.error("Please enter your username.")
    st.stop()

# App Title
st.title("üè• Medisight AI : Claims Processing & FWA Detection")

st.markdown(
    """
Medisight AI streamlines healthcare claim processing by combining Bedrock-powered
analysis, medical-PHI redaction, risk-scoring, and a robust audit trail.
"""
)

# Upload PDF
uploaded_file = st.file_uploader(
    label="Upload Medical Claim PDF",
    type="pdf",
    accept_multiple_files=False,
)

if uploaded_file:
    file_bytes = uploaded_file.read()
    total_pages = len(PdfReader(BytesIO(file_bytes)).pages)
    st.info(f"Uploaded PDF: {uploaded_file.name} ‚Äî {total_pages} pages")

    # PDF Viewer: page-by-page via pdf2image
    pages = convert_from_bytes(file_bytes, dpi=150)
    page_num = st.slider(
        "View PDF Page",
        min_value=1,
        max_value=len(pages),
        value=1,
        help="Slide to view individual pages"
    )
    st.image(
        pages[page_num - 1],
        caption=f"Page {page_num} of {len(pages)}",
        use_column_width=True,
    )
    st.download_button(
        "Download Original PDF",
        data=file_bytes,
        file_name=uploaded_file.name,
        mime="application/pdf",
    )

    # Page selection for analysis
    st.markdown("---")
    selected = st.multiselect(
        "Select pages to analyze",
        options=list(range(1, total_pages + 1)),
        default=list(range(1, total_pages + 1)),
    )

    if st.button("üöÄ Analyze Claim"):
        if not selected:
            st.warning("Please select at least one page.")
        else:
            with st.spinner("Extracting text‚Ä¶"):
                extracted = extract_text_from_pdf(file_bytes, selected)
            st.session_state["extracted_text"] = extracted

            # Store PDF in S3
            claim_id = str(uuid.uuid4())
            s3_key = f"claims/{claim_id}/{uploaded_file.name}"
            s3_path = upload_to_s3("your-s3-bucket", s3_key, file_bytes)

            # Bedrock Analysis
            with st.spinner("Querying Bedrock AI‚Ä¶"):
                analysis = invoke_bedrock_agent(
                    extracted,
                    prompt_prefix="Analyze for Fraud, Waste, and Abuse. Give detailed report."
                )

            # Summarization
            summary = invoke_bedrock_agent(
                extracted,
                prompt_prefix="Provide a concise executive summary of the claim."
            )

            # PHI Detection & Redaction
            entities = detect_phi_entities(extracted)
            redacted_text = mask_phi(extracted, entities)

            # Risk Scoring
            risk_score = compute_risk_score(extracted)

            # Audit log entry
            log_item = {
                "ClaimId": claim_id,
                "Timestamp": int(time.time()),
                "User": username,
                "Role": role,
                "Filename": uploaded_file.name,
                "Pages": selected,
                "RiskScore": risk_score,
                "S3Path": s3_path,
            }
            log_to_dynamodb(log_item)

            # Display Results
            st.success("‚úÖ Analysis Complete")
            st.subheader("Executive Summary")
            st.write(summary)

            st.subheader("FWA Analysis Report")
            st.write(analysis)

            st.subheader("Risk Score")
            st.progress(risk_score / 100)
            st.write(f"{risk_score} / 100")

            st.subheader("Detected PHI Entities")
            phi_table = [
                {
                    "Text": e["Text"],
                    "Category": e["Category"],
                    "Score": f"{e['Score']:.2f}",
                }
                for e in entities
            ]
            st.table(phi_table)

            st.subheader("Redacted Claim Text")
            if role == "auditor":
                st.info("PII hidden in Compliance Mode.")
                st.text_area("Redacted Text", "[REDACTED]" * 50, height=200)
            else:
                st.text_area("Redacted Text", redacted_text, height=200)

            # Store chat history
            st.session_state["chat_history"] = [
                {"role": "assistant", "content": analysis}
            ]

# Chat Interface for Follow-ups
if uploaded_file and "chat_history" in st.session_state:
    st.markdown("---")
    st.subheader("üîç Q&A Assistant")
    for msg in st.session_state["chat_history"]:
        if msg["role"] == "user":
            with st.chat_message("user"):
                st.write(msg["content"])
        else:
            with st.chat_message("assistant"):
                st.write(msg["content"])

    query = st.chat_input("Ask follow-up questions‚Ä¶")
    if query:
        st.session_state["chat_history"].append({"role": "user", "content": query})
        with st.chat_message("user"):
            st.write(query)

        with st.spinner("ü§ñ Thinking‚Ä¶"):
            reply = invoke_bedrock_agent(
                st.session_state["extracted_text"],
                prompt_prefix=f"Answer the user‚Äôs question: {query}"
            )
        st.session_state["chat_history"].append(
            {"role": "assistant", "content": reply}
        )
        with st.chat_message("assistant"):
            st.write(reply)